<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Token.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ACE library</a> &gt; <a href="index.source.html" class="el_package">se.sics.ace.as</a> &gt; <span class="el_source">Token.java</span></div><h1>Token.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2019, RISE AB
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
package se.sics.ace.as;

import java.nio.ByteBuffer;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import org.bouncycastle.crypto.InvalidCipherTextException;
import org.eclipse.californium.elements.auth.RawPublicKeyIdentity;

import com.upokecenter.cbor.CBORObject;
import com.upokecenter.cbor.CBORType;

import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.Encrypt0Message;
import org.eclipse.californium.cose.HeaderKeys;
import org.eclipse.californium.cose.KeyKeys;
import org.eclipse.californium.cose.OneKey;

import se.sics.ace.AccessToken;
import se.sics.ace.AceException;
import se.sics.ace.Constants;
import se.sics.ace.Endpoint;
import se.sics.ace.Message;
import se.sics.ace.TimeProvider;
import se.sics.ace.Util;
import se.sics.ace.as.logging.DhtLogger;
import se.sics.ace.cwt.CWT;
import se.sics.ace.cwt.CwtCryptoCtx;

/**
 * Implements the /token endpoint on the authorization server.
 * 
 * Note: If a client requests a scope that is not supported by (parts) of the
 * audience this endpoint will just ignore that, assuming that the client will
 * be denied by the PDP anyway. This requires a default deny policy in the PDP.
 * 
 * Note: This endpoint assigns a cti to each issued token based on a counter.
 * The same value is also used as kid for the proof-of-possession key associated
 * to the token by means of the 'cnf' claim.
 * 
 * Note: This endpoint assumes that the sender Id (the one you get from
 * Message.getSenderId()) for a secure session created with a raw public key is
 * generated with
 * org.eclipse.californium.scandium.auth.RawPublicKeyIdentity.getName()
 * 
 * @author Ludwig Seitz and Marco Tiloca
 *
 */
public class Token implements Endpoint, AutoCloseable {

	/**
	 * Enums for DHT logging levels
	 */
<span class="fc" id="L96">	private static String TYPE_INFO = &quot;info&quot;;</span>
<span class="fc" id="L97">	private static String TYPE_WARNING = &quot;warning&quot;;</span>
<span class="fc" id="L98">	private static String TYPE_ERROR = &quot;error&quot;;</span>
<span class="fc" id="L99">	private static String PRIO_LOW = &quot;low&quot;;</span>
<span class="fc" id="L100">	private static String PRIO_MEDIUM = &quot;medium&quot;;</span>
<span class="fc" id="L101">	private static String PRIO_HIGH = &quot;high&quot;;</span>
<span class="fc" id="L102">	private static String CAT_STATUS = &quot;status&quot;;</span>
<span class="fc" id="L103">	private static String DEVICE_NAME = &quot;ACE Authorization Server&quot;;</span>

	/**
	 * The logger
	 */
<span class="fc" id="L108">	private static final Logger LOGGER = Logger.getLogger(Token.class.getName());</span>

	/**
	 * Boolean for not verify
	 */
<span class="fc" id="L113">	private static boolean sign = false;</span>

	/**
	 * The PDP this endpoint uses to make access control decisions.
	 */
	private PDP pdp;

	/**
	 * The database connector for storing and retrieving stuff.
	 */
	private DBConnector db;

	/**
	 * The identifier of this AS for the iss claim.
	 */
	private String asId;

	/**
	 * The time provider for this AS.
	 */
	private TimeProvider time;

	/**
	 * The default expiration time of an access token
	 */
<span class="fc" id="L138">	private static long expiration = 1000 * 60 * 10; // 10 minutes</span>

	/**
	 * The counter for generating the cti
	 */
<span class="fc" id="L143">	private Long cti = 0L;</span>

	/**
	 * The private key of the AS or null if there isn't any
	 */
	private OneKey privateKey;

	/**
	 * The client credentials grant type as CBOR-integer
	 */
<span class="fc" id="L153">	public static CBORObject clientCredentials = CBORObject.FromObject(Constants.GT_CLI_CRED);</span>

	/**
	 * The authorizaton_code grant type as CBOR-integer
	 */
<span class="fc" id="L158">	public static CBORObject authzCode = CBORObject.FromObject(Constants.GT_AUTHZ_CODE);</span>

	/**
	 * Converter to create the byte array from the cti number
	 */
<span class="fc" id="L163">	private static ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);</span>

	/**
	 * The claim types included in tokens generated by this Token instance
	 */
	private Set&lt;Short&gt; claims;

<span class="fc" id="L170">	private static Set&lt;Short&gt; defaultClaims = new HashSet&lt;&gt;();</span>

	static {
<span class="fc" id="L173">		defaultClaims.add(Constants.CTI);</span>
<span class="fc" id="L174">		defaultClaims.add(Constants.ISS);</span>
<span class="fc" id="L175">		defaultClaims.add(Constants.EXI);</span>
<span class="fc" id="L176">		defaultClaims.add(Constants.AUD);</span>
<span class="fc" id="L177">		defaultClaims.add(Constants.SCOPE);</span>
<span class="fc" id="L178">		defaultClaims.add(Constants.CNF);</span>
<span class="fc" id="L179">	}</span>

	/**
	 * If true the AUD claim is inserted in the COSE header of a CWT generated
	 * by this AS in order to be able to retrieve the right keys when the CWT is
	 * presented by the client instead of the RS for introspection
	 */
<span class="fc" id="L186">	private boolean setAudHeader = false;</span>

	/**
	 * Incremented after having released an Access Token including OSCORE input
	 * material The current value is used for the 'id' parameter in the OSCORE
	 * Security Context object in 'cnf'
	 */
<span class="fc" id="L193">	private int OSCORE_material_counter = 0;</span>

	/**
	 * Store the association between the cti of an issued Access Token and the
	 * target audience intended to consume it.
	 */
<span class="fc" id="L199">	private Map&lt;String, String&gt; cti2aud = new HashMap&lt;&gt;();</span>

	/**
	 * Store the association between the name of the Resource Server and the
	 * next value to use as Sequence Number to build the 'cti' claim when the
	 * 'exi' claim is included in the Access Token
	 * 
	 * The entry for a Resource Server is created when the first Access Token
	 * including 'exi' is issues, since the AS process has started. The initial
	 * value of the Sequence Number is retrieved from the database.
	 */
<span class="fc" id="L210">	private Map&lt;String, Integer&gt; exiSequenceNumbers = new HashMap&lt;&gt;();</span>

	/**
	 * Relevant only when the DTLS profile is used with symmetric PoP key
	 * 
	 * Store the association between the cti of an issued Acced Token and the
	 * 'kid' of the associated symmetric PoP key generated by the AS
	 */
<span class="fc" id="L218">	private Map&lt;String, CBORObject&gt; cti2kid = new HashMap&lt;&gt;();</span>

	/**
	 * Relevant only when the OSCORE profile is used
	 * 
	 * Store the association between the cti of an issued Acced Token and the ID
	 * identifying the OSCORE Input Material. Such an ID is stored as a CBOR
	 * byte string.
	 */
<span class="fc" id="L227">	private Map&lt;String, CBORObject&gt; cti2oscId = new HashMap&lt;&gt;();</span>

	/**
	 * Relevant only when the OSCORE profile is used
	 * 
	 * The size in bytes of the OSCORE Master Salt to provide to the Client and
	 * to include in the Token. It can be 0, to not provide a Master Salt.
	 */
	private short masterSaltSize;

	/**
	 * Relevant only when the OSCORE profile is used
	 * 
	 * True if the OSCORE Id Context has to be provided, false otherwise
	 */
	private boolean provideIdContext;

	/**
	 * Relevant only when the OSCORE profile is used
	 * 
	 * It specifies information on the next Id Context to assign for each
	 * Resource Server
	 */
<span class="fc" id="L250">	private Map&lt;String, IdContextInfo&gt; idContextInfoMap = new HashMap&lt;&gt;();</span>

	/**
	 * Mapping between security identities of the peers and their names; it can
	 * be null
	 * 
	 * This is relevant especially for the OSCORE profile, since all peers are
	 * registered in the AS database by nicknames. Instead, their OSCORE
	 * identities as retrieved from incoming OSCORE messages are structured
	 * base64 strings encoding the Context ID and Sender ID for that peer
	 */
<span class="fc" id="L261">	private Map&lt;String, String&gt; peerIdentitiesToNames = null;</span>

	/**
	 * Constructor using default set of claims.
	 * 
	 * @param asId the identifier of this AS
	 * @param pdp the PDP for deciding access
	 * @param db the database connector
	 * @param time the time provider
	 * @param privateKey the private key of the AS or null if there isn't any
	 * @param peerIdentitiesToNames mapping between security identities of the
	 *            peers and their names; it can be null
	 * 
	 * @throws AceException if fetching the cti from the database fails
	 */
	public Token(String asId, PDP pdp, DBConnector db, TimeProvider time, OneKey privateKey,
			Map&lt;String, String&gt; peerIdentitiesToNames) throws AceException {
<span class="fc" id="L278">		this(asId, pdp, db, time, privateKey, defaultClaims, false, (short) 0, false, peerIdentitiesToNames);</span>
<span class="fc" id="L279">	}</span>

	/**
	 * Constructor that allows configuration of the claims included in the
	 * token.
	 * 
	 * @param asId the identifier of this AS
	 * @param pdp the PDP for deciding access
	 * @param db the database connector
	 * @param time the time provider
	 * @param privateKey the private key of the AS or null if there isn't any
	 * @param claims the claim types to include in tokens issued by this Token
	 *            instance
	 * @param setAudInCwtHeader if true the AUD claim is inserted in the COSE
	 *            header of a CWT generated by this AS in order to be able to
	 *            retrieve the right keys when the CWT is presented by the
	 *            client instead of the RS for introspection
	 * @param peerIdentitiesToNames mapping between security identities of the
	 *            peers and their names; it can be null
	 * 
	 * @throws AceException if fetching the cti from the database fails
	 */
	public Token(String asId, PDP pdp, DBConnector db, TimeProvider time, OneKey privateKey, Set&lt;Short&gt; claims,
			boolean setAudInCwtHeader, Map&lt;String, String&gt; peerIdentitiesToNames) throws AceException {
<span class="fc" id="L303">		this(asId, pdp, db, time, privateKey, claims, setAudInCwtHeader, (short) 0, false, peerIdentitiesToNames);</span>
<span class="fc" id="L304">	}</span>

	/**
	 * Constructor that allows configuration of everything.
	 * 
	 * @param asId the identifier of this AS
	 * @param pdp the PDP for deciding access
	 * @param db the database connector
	 * @param time the time provider
	 * @param privateKey the private key of the AS or null if there isn't any
	 * @param claims the claim types to include in tokens issued by this Token
	 *            instance
	 * @param setAudInCwtHeader if true the AUD claim is inserted in the COSE
	 *            header of a CWT generated by this AS in order to be able to
	 *            retrieve the right keys when the CWT is presented by the
	 *            client instead of the RS for introspection
	 * @param masterSaltSize the size in bytes of the OSCORE Master Salt
	 * @param provideIdContext true if the OSCORE Id Context has to be provided,
	 *            false otherwise
	 * @param peerIdentitiesToNames mapping between security identities of the
	 *            peers and their names; it can be null
	 * 
	 * @throws AceException if fetching the cti from the database fails
	 */
	public Token(String asId, PDP pdp, DBConnector db, TimeProvider time, OneKey privateKey, Set&lt;Short&gt; claims,
			boolean setAudInCwtHeader, short masterSaltSize, boolean provideIdContext,
<span class="fc" id="L330">			Map&lt;String, String&gt; peerIdentitiesToNames) throws AceException {</span>

<span class="fc" id="L332">		Set&lt;Short&gt; localClaims = claims;</span>

<span class="fc bfc" id="L334" title="All 2 branches covered.">		if (localClaims == null) {</span>
<span class="fc" id="L335">			localClaims = defaultClaims;</span>
		}

		// Time for checks
<span class="pc bpc" id="L339" title="2 of 4 branches missed.">		if (asId == null || asId.isEmpty()) {</span>
<span class="nc" id="L340">			LOGGER.severe(&quot;Token endpoint's AS identifier was null or empty&quot;);</span>
<span class="nc" id="L341">			throw new AceException(&quot;AS identifier must be non-null and non-empty&quot;);</span>
		}
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">		if (pdp == null) {</span>
<span class="nc" id="L344">			LOGGER.severe(&quot;Token endpoint's PDP was null&quot;);</span>
<span class="nc" id="L345">			throw new AceException(&quot;Token endpoint's PDP must be non-null&quot;);</span>
		}
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">		if (db == null) {</span>
<span class="nc" id="L348">			LOGGER.severe(&quot;Token endpoint's DBConnector was null&quot;);</span>
<span class="nc" id="L349">			throw new AceException(&quot;Token endpoint's DBConnector must be non-null&quot;);</span>
		}
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">		if (time == null) {</span>
<span class="nc" id="L352">			LOGGER.severe(&quot;Token endpoint's TimeProvider was null&quot;);</span>
<span class="nc" id="L353">			throw new AceException(&quot;Token endpoint's TimeProvider &quot; + &quot;must be non-null&quot;);</span>
		}
		// All checks passed
<span class="fc" id="L356">		this.asId = asId;</span>
<span class="fc" id="L357">		this.pdp = pdp;</span>
<span class="fc" id="L358">		this.db = db;</span>
<span class="fc" id="L359">		this.time = time;</span>
<span class="fc" id="L360">		this.privateKey = privateKey;</span>
<span class="fc" id="L361">		this.cti = db.getCtiCounter();</span>
<span class="fc" id="L362">		this.claims = new HashSet&lt;&gt;();</span>
<span class="fc" id="L363">		this.claims.addAll(localClaims);</span>
<span class="fc" id="L364">		this.setAudHeader = setAudInCwtHeader;</span>
<span class="fc" id="L365">		this.masterSaltSize = masterSaltSize;</span>
<span class="fc" id="L366">		this.provideIdContext = provideIdContext;</span>
<span class="fc" id="L367">		this.peerIdentitiesToNames = peerIdentitiesToNames;</span>

<span class="fc" id="L369">	}</span>

	@Override
	public Message processMessage(Message msg) {
		// Purge expired tokens from the database
		try {
<span class="fc" id="L375">			this.db.purgeExpiredTokens(this.time.getCurrentTime());</span>
<span class="nc" id="L376">		} catch (AceException e) {</span>
<span class="nc" id="L377">			LOGGER.severe(&quot;Database error: &quot; + e.getMessage());</span>
<span class="nc" id="L378">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L379">		}</span>

<span class="pc bpc" id="L381" title="1 of 2 branches missed.">		if (msg == null) {// This should not happen</span>
<span class="nc" id="L382">			LOGGER.severe(&quot;Token.processMessage() received null message&quot;);</span>
<span class="nc" id="L383">			return null;</span>
		}
<span class="fc" id="L385">		LOGGER.log(Level.INFO, &quot;Token received message: &quot; + msg.getParameters());</span>

		// 1. Check if this client can request tokens
<span class="fc" id="L388">		String id = msg.getSenderId();</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">		if (id == null) {</span>
<span class="fc" id="L390">			CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L391">			map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="fc" id="L392">			LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);</span>
<span class="fc" id="L393">			return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
		}

<span class="fc bfc" id="L396" title="All 2 branches covered.">		if (peerIdentitiesToNames != null) {</span>
<span class="fc" id="L397">			id = peerIdentitiesToNames.get(id);</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">			if (id == null) {</span>
<span class="nc" id="L399">				CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L400">				map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="nc" id="L401">				LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);</span>
<span class="nc" id="L402">				return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
			}
		}

		try {
<span class="fc bfc" id="L407" title="All 2 branches covered.">			if (!this.pdp.canAccessToken(id)) {</span>
<span class="fc" id="L408">				CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L409">				map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="fc" id="L410">				LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);</span>
<span class="fc" id="L411">				return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
			}
<span class="nc" id="L413">		} catch (AceException e) {</span>
<span class="nc" id="L414">			LOGGER.severe(&quot;Database error: &quot; + e.getMessage());</span>
<span class="nc" id="L415">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L416">		}</span>

		// 2. Check that this is a supported grant type
<span class="fc bfc" id="L419" title="All 2 branches covered.">		if (msg.getParameter(Constants.GRANT_TYPE) == null</span>
				// grant type == client credentials implied
<span class="fc bfc" id="L421" title="All 2 branches covered.">				|| msg.getParameter(Constants.GRANT_TYPE).equals(clientCredentials)) {</span>
<span class="fc" id="L422">			return processCC(msg);</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">		} else if (msg.getParameter(Constants.GRANT_TYPE).equals(authzCode)) {</span>
<span class="fc" id="L424">			return processAC(msg);</span>
		}
<span class="fc" id="L426">		CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L427">		map.Add(Constants.ERROR, Constants.UNSUPPORTED_GRANT_TYPE);</span>
<span class="fc" id="L428">		LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unsupported_grant_type&quot;);</span>
<span class="fc" id="L429">		return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
	}

	/**
	 * Process a Client Credentials grant.
	 * 
	 * @param msg the message
	 * @param id the identifier of the requester
	 * 
	 * @return the reply
	 */
	private Message processCC(Message msg) {
<span class="fc" id="L441">		String id = msg.getSenderId();</span>

<span class="fc bfc" id="L443" title="All 2 branches covered.">		if (peerIdentitiesToNames != null) {</span>
<span class="fc" id="L444">			id = peerIdentitiesToNames.get(id);</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">			if (id == null) {</span>
<span class="nc" id="L446">				CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L447">				map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="nc" id="L448">				LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);</span>
<span class="nc" id="L449">				DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);
<span class="nc" id="L451">				return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
			}
		}

		// 3. Check if the request has a scope
<span class="fc" id="L456">		CBORObject cbor = msg.getParameter(Constants.SCOPE);</span>
<span class="fc" id="L457">		Object scope = null;</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">		if (cbor == null) {</span>
			try {
<span class="fc" id="L460">				scope = this.db.getDefaultScope(id);</span>
<span class="nc" id="L461">			} catch (AceException e) {</span>
<span class="nc" id="L462">				LOGGER.severe(&quot;Message processing aborted (checking scope): &quot; + e.getMessage());</span>
<span class="nc" id="L463">				DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Message processing aborted (checking scope)&quot;);
<span class="nc" id="L465">				return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L466">			}</span>
		} else {
<span class="fc bfc" id="L468" title="All 2 branches covered.">			if (cbor.getType().equals(CBORType.TextString)) {</span>
<span class="fc" id="L469">				scope = cbor.AsString();</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">			} else if (cbor.getType().equals(CBORType.ByteString)) {</span>
<span class="fc" id="L471">				scope = cbor.GetByteString();</span>
			} else {
<span class="fc" id="L473">				CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L474">				map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L475">				map.Add(Constants.ERROR_DESCRIPTION, &quot;Invalid datatype for scope&quot;);</span>
<span class="fc" id="L476">				LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Invalid datatype for scope in message&quot;);</span>
<span class="fc" id="L477">				DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Message processing aborted: &quot; + &quot;Invalid datatype for scope in message&quot;);
<span class="fc" id="L479">				return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
			}
		}
<span class="fc bfc" id="L482" title="All 2 branches covered.">		if (scope == null) {</span>
<span class="fc" id="L483">			CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L484">			map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L485">			map.Add(Constants.ERROR_DESCRIPTION, &quot;No scope found for message&quot;);</span>
<span class="fc" id="L486">			LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No scope found for message&quot;);</span>
<span class="fc" id="L487">			DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
					&quot;Message processing aborted: &quot; + &quot;No scope found for message&quot;);
<span class="fc" id="L489">			return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
		}

		// 4. Check if the request has an audience or if there is a default
		// audience
<span class="fc" id="L494">		cbor = msg.getParameter(Constants.AUDIENCE);</span>

		// The audience has to be a text string. A set is built for
		// compatibility with other methods
<span class="fc" id="L498">		Set&lt;String&gt; aud = new HashSet&lt;&gt;();</span>

<span class="fc" id="L500">		String audStr = &quot;&quot;; // used to save the audience for later, for possible</span>
							// update of access rights
<span class="fc" id="L502">		String oldCti = &quot;&quot;; // used to track the cti of a Token to supersede, in</span>
							// case of update of access rights

<span class="fc bfc" id="L505" title="All 2 branches covered.">		if (cbor == null) {</span>
			try {
<span class="fc" id="L507">				String dAud = this.db.getDefaultAudience(id);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">				if (dAud != null) {</span>
<span class="fc" id="L509">					aud.add(dAud);</span>
<span class="fc" id="L510">					audStr = new String(dAud);</span>
				}
<span class="nc" id="L512">			} catch (AceException e) {</span>
<span class="nc" id="L513">				LOGGER.severe(&quot;Message processing aborted (checking aud): &quot; + e.getMessage());</span>
<span class="nc" id="L514">				DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Message processing aborted (checking aud)&quot;);
<span class="nc" id="L516">				return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L517">			}</span>
		} else {
<span class="fc bfc" id="L519" title="All 2 branches covered.">			if (cbor.getType().equals(CBORType.TextString)) {</span>
<span class="fc" id="L520">				aud.add(cbor.AsString());</span>
<span class="fc" id="L521">				audStr = new String(cbor.AsString());</span>
			} else {// error
<span class="fc" id="L523">				CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L524">				map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L525">				map.Add(Constants.ERROR_DESCRIPTION, &quot;Audience malformed&quot;);</span>
<span class="fc" id="L526">				LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Audience malformed&quot;);</span>
<span class="fc" id="L527">				DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Message processing aborted: &quot; + &quot;Audience malformed&quot;);
<span class="fc" id="L529">				return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
			}
		}
<span class="fc bfc" id="L532" title="All 2 branches covered.">		if (aud.isEmpty()) {</span>
<span class="fc" id="L533">			CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L534">			map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L535">			map.Add(Constants.ERROR_DESCRIPTION, &quot;No audience found for message&quot;);</span>
<span class="fc" id="L536">			LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No audience found for message&quot;);</span>
<span class="fc" id="L537">			DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
					&quot;Message processing aborted: &quot; + &quot;No audience found for message&quot;);
<span class="fc" id="L539">			return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
		}

		// 5. Check if the scope is allowed
<span class="fc" id="L543">		Object allowedScopes = null;</span>
		try {
<span class="fc" id="L545">			allowedScopes = this.pdp.canAccess(id, aud, scope);</span>
<span class="nc" id="L546">		} catch (AceException e) {</span>
<span class="nc" id="L547">			LOGGER.severe(&quot;Message processing aborted (checking permissions): &quot; + e.getMessage());</span>
<span class="nc" id="L548">			DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
					&quot;Message processing aborted (checking permissions)&quot;);
<span class="nc" id="L550">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L551">		}</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">		if (allowedScopes == null) {</span>
<span class="fc" id="L553">			CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L554">			map.Add(Constants.ERROR, Constants.INVALID_SCOPE);</span>
<span class="fc" id="L555">			LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;invalid_scope&quot;);</span>
<span class="fc" id="L556">			DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
					&quot;Message processing aborted: &quot; + &quot;invalid_scope&quot;);
<span class="fc" id="L558">			return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
		}

		// 6. Create token
		// Find supported token type
<span class="fc" id="L563">		Short tokenType = null;</span>
		try {
<span class="fc" id="L565">			tokenType = this.db.getSupportedTokenType(aud);</span>
<span class="nc" id="L566">		} catch (AceException e) {</span>
<span class="nc" id="L567">			LOGGER.severe(&quot;Message processing aborted (creating token): &quot; + e.getMessage());</span>
<span class="nc" id="L568">			DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
					&quot;Message processing aborted (creating token)&quot;);
<span class="nc" id="L570">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L571">		}</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">		if (tokenType == null) {</span>
<span class="fc" id="L573">			CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L574">			map.Add(Constants.ERROR, &quot;Audience incompatible on token type&quot;);</span>
<span class="fc" id="L575">			LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Audience incompatible on token type&quot;);</span>
<span class="fc" id="L576">			DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
					&quot;Message processing aborted: &quot; + &quot;Audience incompatible on token type&quot;);
<span class="fc" id="L578">			return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
		}

<span class="fc" id="L581">		boolean includeExi = this.claims.contains(Constants.EXI);</span>
		// If the 'exi' claim is included, ensure that the 'cti' claim is also
		// included
<span class="fc bfc" id="L584" title="All 2 branches covered.">		if (includeExi) {</span>
<span class="fc" id="L585">			this.claims.add(Constants.CTI);</span>
		}

		// The construction of 'cti' depends on the presence/absence of the
		// 'exi' claim.
		//
		// If the 'exi' claim is not present, 'cti' is the serialization of a
		// global counter.
		//
		// If the 'exi' claim is present, 'cti' is the serialization of two
		// concatenated strings, i.e., the name of the Resource Server and the
		// current value of the Exi Sequence Number
<span class="fc" id="L597">		byte[] ctiB = null;</span>
<span class="fc" id="L598">		String ctiStr = null;</span>
<span class="fc" id="L599">		String rsName = null;</span>
<span class="fc" id="L600">		int exiSeqNum = -1;</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">		if (!includeExi) {</span>
			// The 'exi' claim is not included in the Access Token.
			// Thus, 'cti' can be easily built by using the related single
			// counter
<span class="fc" id="L605">			ctiB = buffer.putLong(0, this.cti).array();</span>
<span class="fc" id="L606">			ctiStr = Base64.getEncoder().encodeToString(ctiB);</span>
<span class="fc" id="L607">			this.cti++;</span>
		} else {
			// The 'exi' claim is included in the Access Token.
			//
			// Thus, 'cti' has to be built according to a particular semantics,
			// as the serialization of the text string S1 = (S2 | S3), where S2
			// is the name of the Resource Server and S3 is the text encoding of
			// the Exi Sequence Number to use for that Resource Server.

			// Determine the name of the Resource Server associated to the
			// specified Audience
<span class="fc" id="L618">			Set&lt;String&gt; rsSet = new HashSet&lt;&gt;();</span>
			try {
<span class="fc" id="L620">				rsSet = db.getRSS(audStr);</span>
<span class="nc" id="L621">			} catch (AceException e) {</span>
<span class="nc" id="L622">				LOGGER.severe(&quot;Message processing aborted: Error when retrieving the name&quot;</span>
<span class="nc" id="L623">						+ &quot; of the Resource Server with Audience &quot; + audStr + &quot; from the database.\n&quot; + e.getMessage());</span>
<span class="nc" id="L624">				DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Message processing aborted: Error when retrieving the name&quot;
								+ &quot; of the Resource Server with Audience &quot; + audStr + &quot; from the database.&quot;);
<span class="nc" id="L627">				return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L628">			}</span>
			// Check the the specified Audience is associated to exactly one
			// Resource Server
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">			if (rsSet.size() != 1) {</span>
<span class="nc" id="L632">				CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L633">				map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L634">				map.Add(Constants.ERROR_DESCRIPTION, &quot;The 'exi' claim has to be included, thus Audience must contain&quot;</span>
						+ &quot; exactly one Resource Server&quot;);
<span class="nc" id="L636">				LOGGER.log(Level.INFO, &quot;Message processing aborted: The 'exi' claim has to be included,&quot;</span>
						+ &quot;thus Audience must contain exactly one Resource Server&quot;);
<span class="nc" id="L638">				DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Message processing aborted: The 'exi' claim has to be included,&quot;
								+ &quot;thus Audience must contain exactly one Resource Server&quot;);
<span class="nc" id="L641">				return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
			}
<span class="fc bfc" id="L643" title="All 2 branches covered.">			for (String rs : rsSet)</span>
<span class="fc" id="L644">				rsName = new String(rs);</span>

			// Retrieve the value of the Exi Sequence Number to use for this
			// Resource Server
<span class="fc bfc" id="L648" title="All 2 branches covered.">			if (exiSequenceNumbers.containsKey(rsName)) {</span>
<span class="fc" id="L649">				exiSeqNum = exiSequenceNumbers.get(rsName).intValue();</span>
			} else {
				// This is going to be the first Access Token including the
				// 'exi' claim issued to this Resource Server since the AS
				// process started. Then, retrieve the current Exi Sequence
				// Number value for this Resource Server from the database.
				try {
<span class="fc" id="L656">					exiSeqNum = db.getExiSequenceNumber(rsName);</span>
<span class="nc" id="L657">				} catch (AceException e) {</span>
<span class="nc" id="L658">					LOGGER.severe(&quot;Message processing aborted: Error when retrieving the Exi Sequence Number&quot;</span>
							+ &quot; for the Resource Server with Audience &quot; + audStr + &quot; from the database.\n&quot;
<span class="nc" id="L660">							+ e.getMessage());</span>
<span class="nc" id="L661">					DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
							&quot;Message processing aborted: Error when retrieving the Exi Sequence Number&quot;
									+ &quot; for the Resource Server with Audience &quot; + audStr + &quot; from the database.&quot;);
<span class="nc" id="L664">					return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L665">				}</span>
			}

			// Update the local collection of Exi Sequence Numbers
<span class="fc" id="L669">			Integer newSeqNum = Integer.valueOf(exiSeqNum + 1);</span>
<span class="fc" id="L670">			exiSequenceNumbers.put(rsName, newSeqNum);</span>

<span class="fc" id="L672">			String rawCti = new String(rsName + String.valueOf(exiSeqNum));</span>
<span class="fc" id="L673">			ctiB = rawCti.getBytes(Constants.charset);</span>
<span class="fc" id="L674">			ctiStr = Base64.getEncoder().encodeToString(ctiB);</span>

		}

		// Find supported profile

<span class="fc" id="L680">		String profileStr = null;</span>
		try {
<span class="fc" id="L682">			profileStr = this.db.getSupportedProfile(id, aud);</span>
<span class="nc" id="L683">		} catch (AceException e) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">			if (!includeExi) {</span>
<span class="nc" id="L685">				this.cti--; // roll-back</span>
			} else {
				// roll-back
<span class="nc" id="L688">				exiSequenceNumbers.put(rsName, exiSeqNum);</span>
			}
<span class="nc" id="L690">			LOGGER.severe(&quot;Message processing aborted (finding profile): &quot; + e.getMessage());</span>
<span class="nc" id="L691">			DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
					&quot;Message processing aborted (finding profile)&quot;);
<span class="nc" id="L693">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L694">		}</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">		if (profileStr == null) {</span>
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">			if (!includeExi) {</span>
<span class="nc" id="L697">				this.cti--; // roll-back</span>
			} else {
				// roll-back
<span class="fc" id="L700">				exiSequenceNumbers.put(rsName, exiSeqNum);</span>
			}
<span class="fc" id="L702">			CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L703">			map.Add(Constants.ERROR, Constants.INCOMPATIBLE_PROFILES);</span>
<span class="fc" id="L704">			LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No compatible profile found&quot;);</span>
<span class="fc" id="L705">			DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
					&quot;Message processing aborted: &quot; + &quot;No compatible profile found&quot;);
<span class="fc" id="L707">			return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
		}
<span class="fc" id="L709">		short profile = Constants.getProfileAbbrev(profileStr);</span>

<span class="fc bfc" id="L711" title="All 4 branches covered.">		if (tokenType != AccessTokenFactory.CWT_TYPE &amp;&amp; tokenType != AccessTokenFactory.REF_TYPE) {</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">			if (!includeExi) {</span>
<span class="nc" id="L713">				this.cti--; // roll-back</span>
			} else {
				// roll-back
<span class="fc" id="L716">				exiSequenceNumbers.put(rsName, exiSeqNum);</span>
			}
<span class="fc" id="L718">			CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L719">			map.Add(Constants.ERROR, &quot;Unsupported token type&quot;);</span>
<span class="fc" id="L720">			LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported token type&quot;);</span>
<span class="fc" id="L721">			DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
					&quot;Message processing aborted: &quot; + &quot;Unsupported token type&quot;);
<span class="fc" id="L723">			return msg.failReply(Message.FAIL_NOT_IMPLEMENTED, map);</span>
		}

		// This flag will be set to true if the Token is intended to update
		// access rights
<span class="fc" id="L728">		boolean updateAccessRights = false;</span>

<span class="fc" id="L730">		String keyType = null; // Save the key type for later</span>
<span class="fc" id="L731">		Map&lt;Short, CBORObject&gt; claims = new HashMap&lt;&gt;();</span>

		// ISS SUB AUD EXP NBF IAT CTI SCOPE CNF RS_CNF PROFILE EXI
<span class="fc bfc" id="L734" title="All 2 branches covered.">		for (Short c : this.claims) {</span>
<span class="pc bpc" id="L735" title="6 of 12 branches missed.">			switch (c) {</span>
			case Constants.ISS:
<span class="fc" id="L737">				claims.put(Constants.ISS, CBORObject.FromObject(this.asId));</span>
<span class="fc" id="L738">				break;</span>
			case Constants.SUB:
<span class="nc" id="L740">				claims.put(Constants.SUB, CBORObject.FromObject(id));</span>
<span class="nc" id="L741">				break;</span>
			case Constants.AUD:
				// Check if AUDIENCE is a singleton
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">				if (aud.size() == 1) {</span>
<span class="fc" id="L745">					claims.put(Constants.AUD, CBORObject.FromObject(aud.iterator().next()));</span>
				} else {
<span class="nc" id="L747">					claims.put(Constants.AUD, CBORObject.FromObject(aud));</span>
				}
<span class="nc" id="L749">				break;</span>
			case Constants.EXP:
<span class="nc" id="L751">				long now = this.time.getCurrentTime();</span>
<span class="nc" id="L752">				long exp = Long.MAX_VALUE;</span>
				try {
<span class="nc" id="L754">					exp = this.db.getExpTime(aud);</span>
<span class="nc" id="L755">				} catch (AceException e) {</span>
<span class="nc" id="L756">					LOGGER.severe(&quot;Message processing aborted (setting exp): &quot; + e.getMessage());</span>
<span class="nc" id="L757">					DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
							&quot;Message processing aborted (setting exp)&quot;);
<span class="nc" id="L759">					return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="nc" id="L760">				}</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">				if (exp == Long.MAX_VALUE) { // == No expiration time found</span>
					// using default
<span class="nc" id="L763">					exp = now + expiration;</span>
				} else {
<span class="nc" id="L765">					exp = now + exp;</span>
				}
<span class="nc" id="L767">				claims.put(Constants.EXP, CBORObject.FromObject(exp));</span>
<span class="nc" id="L768">				break;</span>
			case Constants.EXI:
<span class="fc" id="L770">				long exi = Long.MAX_VALUE;</span>
				try {
<span class="fc" id="L772">					exi = this.db.getExpTime(aud);</span>
<span class="nc" id="L773">				} catch (AceException e) {</span>
<span class="nc" id="L774">					LOGGER.severe(&quot;Message processing aborted (setting exp): &quot; + e.getMessage());</span>
<span class="nc" id="L775">					DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
							&quot;Message processing aborted (setting exp)&quot;);
<span class="nc" id="L777">					return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L778">				}</span>
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">				if (exi == Long.MAX_VALUE) { // == No expiration time found</span>
					// using default
<span class="nc" id="L781">					exi = expiration;</span>
				}
<span class="fc" id="L783">				claims.put(Constants.EXI, CBORObject.FromObject(exi));</span>
<span class="fc" id="L784">				break;</span>
			case Constants.NBF:
				// XXX: NBF is not configurable in this version
<span class="nc" id="L787">				now = this.time.getCurrentTime();</span>
<span class="nc" id="L788">				claims.put(Constants.NBF, CBORObject.FromObject(now));</span>
<span class="nc" id="L789">				break;</span>
			case Constants.IAT:
<span class="nc" id="L791">				now = this.time.getCurrentTime();</span>
<span class="nc" id="L792">				claims.put(Constants.IAT, CBORObject.FromObject(now));</span>
<span class="nc" id="L793">				break;</span>
			case Constants.CTI:
<span class="fc" id="L795">				claims.put(Constants.CTI, CBORObject.FromObject(ctiB));</span>
<span class="fc" id="L796">				break;</span>
			case Constants.SCOPE:
<span class="fc" id="L798">				claims.put(Constants.SCOPE, CBORObject.FromObject(allowedScopes));</span>
<span class="fc" id="L799">				break;</span>
			case Constants.CNF:
<span class="fc" id="L801">				CBORObject cnf = msg.getParameter(Constants.REQ_CNF);</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">				if (cnf == null) { // The client wants to use PSK</span>
<span class="fc" id="L803">					keyType = &quot;PSK&quot;; // save for later</span>

					// check if PSK is supported for proof-of-possession
					try {
<span class="fc bfc" id="L807" title="All 2 branches covered.">						if (!isSupported(keyType, aud)) {</span>
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">							if (!includeExi) {</span>
<span class="nc" id="L809">								this.cti--; // roll-back</span>
							} else {
								// roll-back
<span class="fc" id="L812">								exiSequenceNumbers.put(rsName, exiSeqNum);</span>
							}
<span class="fc" id="L814">							CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L815">							map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="fc" id="L816">							LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type PSK&quot;);</span>
<span class="fc" id="L817">							DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
									&quot;Message processing aborted: &quot; + &quot;Unsupported pop key type PSK&quot;);
<span class="fc" id="L819">							return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
						}
<span class="nc" id="L821">					} catch (AceException e) {</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">						if (!includeExi) {</span>
<span class="nc" id="L823">							this.cti--; // roll-back</span>
						} else {
							// roll-back
<span class="nc" id="L826">							exiSequenceNumbers.put(rsName, exiSeqNum);</span>
						}
<span class="nc" id="L828">						LOGGER.severe(&quot;Message processing aborted &quot; + &quot;(finding key type): &quot; + e.getMessage());</span>
<span class="nc" id="L829">						DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
								&quot;Message processing aborted &quot; + &quot;(finding key type)&quot;);
<span class="nc" id="L831">						return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L832">					}</span>

					// Audience supports PSK, make a new PSK
					try {
<span class="fc" id="L836">						KeyGenerator kg = KeyGenerator.getInstance(&quot;AES&quot;);</span>

						// OSCORE profile
<span class="fc bfc" id="L839" title="All 2 branches covered.">						if (profile == Constants.COAP_OSCORE) {</span>
							// Generate OSCORE cnf
<span class="fc" id="L841">							SecretKey key = kg.generateKey();</span>
<span class="fc" id="L842">							byte[] masterSecret = key.getEncoded();</span>
<span class="fc" id="L843">							CBORObject osc = makeOscoreCnf(masterSecret, audStr);</span>
<span class="fc" id="L844">							claims.put(Constants.CNF, osc);</span>
<span class="fc" id="L845">						}</span>
						// DTLS profile
						else {
							// Make a DTLS style psk
<span class="fc" id="L849">							CBORObject keyData = CBORObject.NewMap();</span>
<span class="fc" id="L850">							CBORObject coseKey = CBORObject.NewMap();</span>

<span class="fc" id="L852">							keyData.Add(KeyKeys.KeyType.AsCBOR(), KeyKeys.KeyType_Octet);</span>

							// Note: kid is the same as cti
<span class="fc" id="L855">							byte[] kid = ctiB;</span>
<span class="fc" id="L856">							keyData.Add(KeyKeys.KeyId.AsCBOR(), kid);</span>

<span class="fc" id="L858">							SecretKey key = kg.generateKey();</span>
<span class="fc" id="L859">							keyData.Add(KeyKeys.Octet_K.AsCBOR(), CBORObject.FromObject(key.getEncoded()));</span>

<span class="fc" id="L861">							OneKey psk = new OneKey(keyData);</span>
<span class="fc" id="L862">							coseKey.Add(Constants.COSE_KEY, psk.AsCBOR());</span>
<span class="fc" id="L863">							claims.put(Constants.CNF, coseKey);</span>
						}
<span class="nc" id="L865">					} catch (NoSuchAlgorithmException | CoseException e) {</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">						if (!includeExi) {</span>
<span class="nc" id="L867">							this.cti--; // roll-back</span>
						} else {
							// roll-back
<span class="nc" id="L870">							exiSequenceNumbers.put(rsName, exiSeqNum);</span>
						}
<span class="nc" id="L872">						LOGGER.severe(&quot;Message processing aborted &quot; + &quot;(making PSK): &quot; + e.getMessage());</span>
<span class="nc" id="L873">						DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
								&quot;Message processing aborted &quot; + &quot;(making PSK)&quot;);
<span class="nc" id="L875">						return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L876">					}</span>

<span class="fc bfc" id="L878" title="All 2 branches covered.">				} else if (cnf.ContainsKey(Constants.COSE_KID_CBOR)) {</span>
					// The client requested a specific kid

					// Check that the kid is well-formed
<span class="fc" id="L882">					CBORObject kidC = cnf.get(Constants.COSE_KID_CBOR);</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">					if (!kidC.getType().equals(CBORType.ByteString)) {</span>
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">						if (!includeExi) {</span>
<span class="nc" id="L885">							this.cti--; // roll-back</span>
						} else {
							// roll-back
<span class="fc" id="L888">							exiSequenceNumbers.put(rsName, exiSeqNum);</span>
						}
<span class="fc" id="L890">						LOGGER.info(&quot;Message processing aborted: &quot; + &quot; Malformed kid in request parameter 'cnf'&quot;);</span>
<span class="fc" id="L891">						DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
								&quot;Message processing aborted: &quot; + &quot; Malformed kid in request parameter 'cnf'&quot;);
<span class="fc" id="L893">						CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L894">						map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L895">						map.Add(Constants.ERROR_DESCRIPTION, &quot;Malformed kid in 'cnf' parameter&quot;);</span>
<span class="fc" id="L896">						return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
					}
<span class="fc" id="L898">					keyType = &quot;KID&quot;;</span>

					// Check if the new Token is intended to update the access
					// rights for this client
<span class="fc" id="L902">					Set&lt;String&gt; ctiSet = new HashSet&lt;&gt;();</span>
					try {
<span class="fc" id="L904">						ctiSet = this.db.getCtis4Client(id);</span>

<span class="nc" id="L906">					} catch (AceException e) {</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">						if (!includeExi) {</span>
<span class="nc" id="L908">							this.cti--; // roll-back</span>
						} else {
							// roll-back
<span class="nc" id="L911">							exiSequenceNumbers.put(rsName, exiSeqNum);</span>
						}
<span class="nc" id="L913">						LOGGER.severe(</span>
<span class="nc" id="L914">								&quot;Message processing aborted &quot; + &quot;(finding cti of issues tokens): &quot; + e.getMessage());</span>
<span class="nc" id="L915">						DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
								&quot;Message processing aborted &quot; + &quot;(finding cti of issues tokens)&quot;);
<span class="nc" id="L917">						return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L918">					}</span>

<span class="pc bpc" id="L920" title="1 of 2 branches missed.">					if (ctiSet.size() != 0) {</span>
						// Some Tokens have been issued to this client.

<span class="pc bpc" id="L923" title="1 of 2 branches missed.">						for (String myCti : ctiSet) {</span>

							// Check that not only the Token was released at
							// some point in time, but that it is also currently
							// stored in the Database. If so, it is possible to
							// retrieve a non empty set of claims through its
							// cti.
							try {
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">								if (this.db.getClaims(myCti).size() == 0) {</span>
									// A Token with this cti is not active
									// anymore. Continue with checking the next
									// Token.

									// But first take the opportunity to clean
									// up some other data structures, which
									// might not have happened already
<span class="nc" id="L939">									this.cti2aud.remove(myCti);</span>
<span class="nc" id="L940">									this.cti2oscId.remove(myCti);</span>
<span class="nc" id="L941">									this.cti2kid.remove(myCti);</span>

<span class="nc" id="L943">									continue;</span>
								}
<span class="nc" id="L945">							} catch (AceException e) {</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">								if (!includeExi) {</span>
<span class="nc" id="L947">									this.cti--; // roll-back</span>
								} else {
									// roll-back
<span class="nc" id="L950">									exiSequenceNumbers.put(rsName, exiSeqNum);</span>
								}
<span class="nc" id="L952">								LOGGER.severe(&quot;Message processing aborted &quot; + &quot;(finding previously released token): &quot;</span>
<span class="nc" id="L953">										+ e.getMessage());</span>
<span class="nc" id="L954">								DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
										&quot;Message processing aborted &quot; + &quot;(finding previously released token)&quot;);
<span class="nc" id="L956">								return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L957">							}</span>

<span class="fc" id="L959">							String myAud = this.cti2aud.get(myCti);</span>

							// Check especially if the previously released Token
							// was intended to the same Resource Server intended
							// to consume the just requested Token
<span class="pc bpc" id="L964" title="1 of 4 branches missed.">							if (myAud != null &amp;&amp; audStr.equals(myAud)) {</span>

								// Retrieve the claims of the previously
								// released Token
<span class="fc" id="L968">								Map&lt;Short, CBORObject&gt; myClaims = null;</span>
								try {
<span class="fc" id="L970">									myClaims = this.db.getClaims(myCti);</span>
<span class="nc" id="L971">								} catch (AceException e) {</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">									if (!includeExi) {</span>
<span class="nc" id="L973">										this.cti--; // roll-back</span>
									} else {
										// roll-back
<span class="nc" id="L976">										exiSequenceNumbers.put(rsName, exiSeqNum);</span>
									}
<span class="nc" id="L978">									LOGGER.severe(&quot;Message processing aborted &quot;</span>
<span class="nc" id="L979">											+ &quot;(finding previously released token): &quot; + e.getMessage());</span>
<span class="nc" id="L980">									DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
											&quot;Message processing aborted &quot; + &quot;(finding previously released token)&quot;);
<span class="nc" id="L982">									return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L983">								}</span>

<span class="fc" id="L985">								CBORObject oldCnf = myClaims.get(Constants.CNF);</span>

<span class="pc bpc" id="L987" title="1 of 2 branches missed.">								if (oldCnf.get(Constants.COSE_KID) != null) {</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">									if (Arrays.equals(kidC.GetByteString(),</span>
<span class="nc" id="L989">											oldCnf.get(Constants.COSE_KID).GetByteString())) {</span>
										// The new Token is intended to update
										// access rights (not the first update
										// in the series)
<span class="nc" id="L993">										updateAccessRights = true;</span>
<span class="nc" id="L994">										oldCti = new String(myCti);</span>
<span class="nc" id="L995">										break;</span>
									}
									continue;
								}

								// OSCORE profile
<span class="fc bfc" id="L1001" title="All 2 branches covered.">								if (profile == Constants.COAP_OSCORE) {</span>
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">									if (Arrays.equals(kidC.GetByteString(), oldCnf.get(Constants.OSCORE_Input_Material)</span>
<span class="fc" id="L1003">											.get(Constants.OS_ID).GetByteString())) {</span>
										// The new Token is intended to update
										// access rights (first update in the
										// series)
<span class="fc" id="L1007">										updateAccessRights = true;</span>
<span class="fc" id="L1008">										oldCti = new String(myCti);</span>
<span class="fc" id="L1009">										break;</span>
									}
									continue;
								}
								// DTLS profile
								else {
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">									if (Arrays.equals(kidC.GetByteString(), oldCnf.get(Constants.COSE_KEY)</span>
<span class="fc" id="L1016">											.get(KeyKeys.KeyId.AsCBOR()).GetByteString())) {</span>
										// The new Token is intended to update
										// access rights (first update in the
										// series)
<span class="fc" id="L1020">										updateAccessRights = true;</span>
<span class="fc" id="L1021">										oldCti = new String(myCti);</span>
<span class="fc" id="L1022">										break;</span>
									}
									continue;
								}
							}
<span class="fc" id="L1027">						}</span>

<span class="pc bpc" id="L1029" title="1 of 2 branches missed.">						if (updateAccessRights == true) {</span>
							// The new Token is intended to update access rights

							// OSCORE profile
<span class="fc bfc" id="L1033" title="All 2 branches covered.">							if (profile == Constants.COAP_OSCORE) {</span>
								// Generate OSCORE cnf
<span class="fc" id="L1035">								CBORObject oscId = this.cti2oscId.get(oldCti);</span>
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">								if (oscId == null) {</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">									if (!includeExi) {</span>
<span class="nc" id="L1038">										this.cti--; // roll-back</span>
									} else {
										// roll-back
<span class="nc" id="L1041">										exiSequenceNumbers.put(rsName, exiSeqNum);</span>
									}
<span class="nc" id="L1043">									LOGGER.severe(&quot;Message processing aborted &quot;</span>
											+ &quot;(finding OSCORE ID when updating access rights)&quot;);
<span class="nc" id="L1045">									DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
											&quot;Message processing aborted &quot;
													+ &quot;(finding OSCORE ID when updating access rights)&quot;);
<span class="nc" id="L1048">									return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
								}
<span class="fc" id="L1050">								CBORObject osc = makeOscoreCnfUpdateAccessRights(oscId);</span>
<span class="fc" id="L1051">								claims.put(Constants.CNF, osc);</span>
<span class="fc" id="L1052">							}</span>
							// DTLS profile
							else {
								// Make a DTLS style psk
<span class="fc" id="L1056">								CBORObject keyData = CBORObject.NewMap();</span>
<span class="fc" id="L1057">								CBORObject coseKey = CBORObject.NewMap();</span>

<span class="fc" id="L1059">								keyData.Add(KeyKeys.KeyType.AsCBOR(), KeyKeys.KeyType_Octet);</span>

<span class="fc" id="L1061">								CBORObject kidCbor = this.cti2kid.get(oldCti);</span>

<span class="fc" id="L1063">								keyData.Add(KeyKeys.KeyId.AsCBOR(), kidCbor);</span>

<span class="fc" id="L1065">								coseKey.Add(Constants.COSE_KEY, keyData);</span>
<span class="fc" id="L1066">								claims.put(Constants.CNF, coseKey);</span>
<span class="fc" id="L1067">							}</span>
						} else {
<span class="nc" id="L1069">							LOGGER.severe(&quot;Message processing aborted &quot;</span>
									+ &quot;(cannot find access token for which access right have to be updated)&quot;);
<span class="nc" id="L1071">							DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
									&quot;Message processing aborted &quot;
											+ &quot;(cannot find access token for which access right have to be updated)&quot;);
<span class="nc" id="L1074">							CBORObject myMap = CBORObject.NewMap();</span>
<span class="nc" id="L1075">							myMap.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="nc" id="L1076">							return msg.failReply(Message.FAIL_BAD_REQUEST, myMap);</span>
						}
					}

<span class="fc" id="L1080">				} else {// Client has provided a key</span>
					// Check what key the client provided
<span class="fc" id="L1082">					OneKey key = null;</span>
					try {
<span class="fc" id="L1084">						key = getKey(cnf, id);</span>
<span class="fc" id="L1085">					} catch (AceException | CoseException e) {</span>
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">						if (!includeExi) {</span>
<span class="nc" id="L1087">							this.cti--; // roll-back</span>
						} else {
							// roll-back
<span class="fc" id="L1090">							exiSequenceNumbers.put(rsName, exiSeqNum);</span>
						}
<span class="fc" id="L1092">						LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="fc" id="L1093">						DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="fc bfc" id="L1094" title="All 2 branches covered.">						if (e.getMessage().startsWith(&quot;Malformed&quot;)) {</span>
<span class="fc" id="L1095">							CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1096">							map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L1097">							map.Add(Constants.ERROR_DESCRIPTION, &quot;Malformed 'cnf' parameter in request&quot;);</span>
<span class="fc" id="L1098">							return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
						}
<span class="fc" id="L1100">						return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1101">					}</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">					if (key == null) {</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">						if (!includeExi) {</span>
<span class="nc" id="L1104">							this.cti--; // roll-back</span>
						} else {
							// roll-back
<span class="nc" id="L1107">							exiSequenceNumbers.put(rsName, exiSeqNum);</span>
						}
<span class="nc" id="L1109">						CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1110">						map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L1111">						map.Add(Constants.ERROR_DESCRIPTION, &quot;Couldn't retrieve RPK&quot;);</span>
<span class="nc" id="L1112">						LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Couldn't retrieve RPK&quot;);</span>
<span class="nc" id="L1113">						DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
								&quot;Message processing aborted: &quot; + &quot;Couldn't retrieve RPK&quot;);
<span class="nc" id="L1115">						return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
					}

<span class="fc bfc" id="L1118" title="All 2 branches covered.">					if (key.get(KeyKeys.KeyType).equals(KeyKeys.KeyType_Octet)) {</span>
						// Client tried to submit a symmetric key =&gt; reject
<span class="pc bpc" id="L1120" title="1 of 2 branches missed.">						if (!includeExi) {</span>
<span class="nc" id="L1121">							this.cti--; // roll-back</span>
						} else {
							// roll-back
<span class="fc" id="L1124">							exiSequenceNumbers.put(rsName, exiSeqNum);</span>
						}
<span class="fc" id="L1126">						CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1127">						map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L1128">						map.Add(Constants.ERROR_DESCRIPTION, &quot;Client tried to provide cnf PSK&quot;);</span>
<span class="fc" id="L1129">						LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Client tried to provide cnf PSK&quot;);</span>
<span class="fc" id="L1130">						DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
								&quot;Message processing aborted: &quot; + &quot;Client tried to provide cnf PSK&quot;);
<span class="fc" id="L1132">						return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
					}

					// At this point we assume the client wants to use RPK
<span class="fc" id="L1136">					keyType = &quot;RPK&quot;;</span>

					// Check that the client used this RPK to create this
					// session
					try {
<span class="fc" id="L1141">						RawPublicKeyIdentity rpkId = new RawPublicKeyIdentity(key.AsPublicKey());</span>
<span class="pc bpc" id="L1142" title="1 of 2 branches missed.">						if (!rpkId.getName().equals(id)) {</span>
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">							if (!includeExi) {</span>
<span class="nc" id="L1144">								this.cti--; // roll-back</span>
							} else {
								// roll-back
<span class="fc" id="L1147">								exiSequenceNumbers.put(rsName, exiSeqNum);</span>
							}
<span class="fc" id="L1149">							CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1150">							map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="fc" id="L1151">							LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Client used unauthenticated RPK&quot;);</span>
<span class="fc" id="L1152">							DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
									&quot;Message processing aborted: &quot; + &quot;Client used unauthenticated RPK&quot;);
<span class="fc" id="L1154">							return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
						}

<span class="nc" id="L1157">					} catch (CoseException e) {</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">						if (!includeExi) {</span>
<span class="nc" id="L1159">							this.cti--; // roll-back</span>
						} else {
							// roll-back
<span class="nc" id="L1162">							exiSequenceNumbers.put(rsName, exiSeqNum);</span>
						}
<span class="nc" id="L1164">						CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1165">						map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="nc" id="L1166">						LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);</span>
<span class="nc" id="L1167">						DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
								&quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);
<span class="nc" id="L1169">						LOGGER.log(Level.FINEST, e.getMessage());</span>
<span class="nc" id="L1170">						return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
<span class="nc" id="L1171">					}</span>

					// Can the audience support this?
					try {
<span class="nc bnc" id="L1175" title="All 2 branches missed.">						if (!isSupported(keyType, aud)) {</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">							if (!includeExi) {</span>
<span class="nc" id="L1177">								this.cti--; // roll-back</span>
							} else {
								// roll-back
<span class="nc" id="L1180">								exiSequenceNumbers.put(rsName, exiSeqNum);</span>
							}
<span class="nc" id="L1182">							CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1183">							map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="nc" id="L1184">							LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);</span>
<span class="nc" id="L1185">							DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
									&quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);
<span class="nc" id="L1187">							return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
						}
<span class="nc" id="L1189">					} catch (AceException e) {</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">						if (!includeExi) {</span>
<span class="nc" id="L1191">							this.cti--; // roll-back</span>
						} else {
							// roll-back
<span class="nc" id="L1194">							exiSequenceNumbers.put(rsName, exiSeqNum);</span>
						}
<span class="nc" id="L1196">						LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1197">						DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1198">						return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="nc" id="L1199">					}</span>

					// Audience support RPK, use provided RPK
<span class="nc" id="L1202">					CBORObject coseKey = CBORObject.NewMap();</span>
<span class="nc" id="L1203">					coseKey.Add(Constants.COSE_KEY, key.AsCBOR());</span>
<span class="nc" id="L1204">					claims.put(Constants.CNF, coseKey);</span>
				}
<span class="nc" id="L1206">				break;</span>
			case Constants.PROFILE:
<span class="nc" id="L1208">				claims.put(Constants.PROFILE, CBORObject.FromObject(profile));</span>
<span class="nc" id="L1209">				break;</span>
			default:
<span class="nc" id="L1211">				LOGGER.severe(&quot;Unknown claim type in /token endpoint configuration: &quot; + c);</span>
<span class="nc" id="L1212">				DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Unknown claim type in /token endpoint configuration: &quot; + c);
<span class="nc" id="L1214">				return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
			}
<span class="fc" id="L1216">		}</span>

<span class="fc" id="L1218">		AccessToken token = null;</span>
		try {
<span class="fc" id="L1220">			token = AccessTokenFactory.generateToken(tokenType, claims);</span>
<span class="nc" id="L1221">		} catch (AceException e) {</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">			if (!includeExi) {</span>
<span class="nc" id="L1223">				this.cti--; // roll-back</span>
			} else {
				// roll-back
<span class="nc" id="L1226">				exiSequenceNumbers.put(rsName, exiSeqNum);</span>
			}

			// If the OSCORE profile is used, and this was a first-released
			// Token to this client for RS in question, roll-back the counter
			// used for the 'id' parameter in the OSCORE Security Context and
			// the Id Context value assigned for this Resource Server
<span class="nc bnc" id="L1233" title="All 4 branches missed.">			if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1234">				this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">				if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1236">					this.idContextInfoMap.get(audStr).rollback();</span>
				}
			}

<span class="nc" id="L1240">			LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1241">			DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1242">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1243">		}</span>

<span class="fc" id="L1245">		CBORObject rsInfo = CBORObject.NewMap();</span>
		try {

<span class="fc" id="L1248">			boolean includeProfile = false;</span>

<span class="fc bfc" id="L1250" title="All 2 branches covered.">			if (!this.db.hasDefaultProfile(id)) {</span>
				// This client supports multiple profiles; need to specify the
				// exact one to use
<span class="fc" id="L1253">				includeProfile = true;</span>
			} else {
<span class="fc" id="L1255">				CBORObject profileParameter = msg.getParameter(Constants.PROFILE);</span>
<span class="pc bpc" id="L1256" title="3 of 4 branches missed.">				if (profileParameter != null &amp;&amp; profileParameter.equals(CBORObject.Null)) {</span>
					// The client has requested an explicit indication of the
					// profile to use
<span class="nc" id="L1259">					includeProfile = true;</span>
				}
			}

<span class="fc bfc" id="L1263" title="All 2 branches covered.">			if (includeProfile == true) {</span>
<span class="fc" id="L1264">				rsInfo.Add(Constants.PROFILE, CBORObject.FromObject(profile));</span>
			}
			// Otherwise, no need to explicitly indicate the used profile

<span class="nc" id="L1268">		} catch (AceException e) {</span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">			if (!includeExi) {</span>
<span class="nc" id="L1270">				this.cti--; // roll-back</span>
			} else {
				// roll-back
<span class="nc" id="L1273">				exiSequenceNumbers.put(rsName, exiSeqNum);</span>
			}

			// If the OSCORE profile is used, and this was a first-released
			// Token to this client for RS in question, roll-back the counter
			// used for the 'id' parameter in the OSCORE Security Context and
			// the Id Context value assigned for this Resource Server
<span class="nc bnc" id="L1280" title="All 4 branches missed.">			if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1281">				this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">				if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1283">					this.idContextInfoMap.get(audStr).rollback();</span>
				}
			}

<span class="nc" id="L1287">			LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1288">			DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1289">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1290">		}</span>

<span class="fc bfc" id="L1292" title="All 4 branches covered.">		if (keyType != null &amp;&amp; keyType.equals(&quot;PSK&quot;)) {</span>
<span class="fc bfc" id="L1293" title="All 2 branches covered.">			if (profile == Constants.COAP_OSCORE) {</span>

<span class="pc bpc" id="L1295" title="1 of 2 branches missed.">				if (updateAccessRights == false) {</span>
<span class="fc" id="L1296">					rsInfo.Add(Constants.CNF, claims.get(Constants.CNF));</span>
				}
				// Do not add 'cnf' if the OSCORE profile is used and
				// the Token is released for updating access rights

			} else {
<span class="fc" id="L1302">				rsInfo.Add(Constants.CNF, claims.get(Constants.CNF));</span>
			}
<span class="pc bpc" id="L1304" title="1 of 4 branches missed.">		} else if (keyType != null &amp;&amp; keyType.equals(&quot;RPK&quot;)) {</span>
<span class="nc" id="L1305">			Set&lt;CBORObject&gt; rscnfs = new HashSet&lt;&gt;();</span>
			try {
<span class="nc" id="L1307">				rscnfs = makeRsCnf(aud);</span>
<span class="nc" id="L1308">			} catch (AceException e) {</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">				if (!includeExi) {</span>
<span class="nc" id="L1310">					this.cti--; // roll-back</span>
				} else {
					// roll-back
<span class="nc" id="L1313">					exiSequenceNumbers.put(rsName, exiSeqNum);</span>
				}

				// If the OSCORE profile is used, and this was a first-released
				// Token to this client for RS in question, roll-back the
				// counter used for the 'id' parameter in the OSCORE Security
				// Context and the Id Context value assigned for this Resource
				// Server
<span class="nc bnc" id="L1321" title="All 4 branches missed.">				if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1322">					this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">					if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1324">						this.idContextInfoMap.get(audStr).rollback();</span>
					}
				}

<span class="nc" id="L1328">				LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1329">				DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1330">				return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="nc" id="L1331">			}</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">			for (CBORObject rscnf : rscnfs) {</span>
<span class="nc" id="L1333">				rsInfo.Add(Constants.RS_CNF, rscnf);</span>
<span class="nc" id="L1334">			}</span>
		} // Skip cnf if client requested specific KID.

		// Handle &quot;scope&quot; both as String and as Byte Array
<span class="fc bfc" id="L1338" title="All 4 branches covered.">		if (scope instanceof String &amp;&amp; !allowedScopes.equals(scope)) {</span>
<span class="fc" id="L1339">			rsInfo.Add(Constants.SCOPE, CBORObject.FromObject(allowedScopes));</span>
		}
<span class="fc bfc" id="L1341" title="All 4 branches covered.">		if (scope instanceof byte[] &amp;&amp; !(Arrays.equals((byte[]) allowedScopes, (byte[]) scope))) {</span>
<span class="fc" id="L1342">			rsInfo.Add(Constants.SCOPE, CBORObject.FromObject(allowedScopes));</span>
		}

<span class="fc bfc" id="L1345" title="All 2 branches covered.">		if (token instanceof CWT) {</span>

<span class="fc" id="L1347">			CwtCryptoCtx ctx = null;</span>
			try {
<span class="fc" id="L1349">				ctx = EndpointUtils.makeCommonCtx(aud, this.db, this.privateKey, sign);</span>
<span class="nc" id="L1350">			} catch (AceException | CoseException e) {</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">				if (!includeExi) {</span>
<span class="nc" id="L1352">					this.cti--; // roll-back</span>
				} else {
					// roll-back
<span class="nc" id="L1355">					exiSequenceNumbers.put(rsName, exiSeqNum);</span>
				}

				// If the OSCORE profile is used, and this was a first-released
				// Token to this client for RS in question, roll-back the
				// counter used for the 'id' parameter in the OSCORE Security
				// Context and the Id Context value assigned for this Resource
				// Server
<span class="nc bnc" id="L1363" title="All 4 branches missed.">				if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1364">					this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">					if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1366">						this.idContextInfoMap.get(audStr).rollback();</span>
					}
				}

<span class="nc" id="L1370">				LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1371">				DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1372">				return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1373">			}</span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">			if (ctx == null) {</span>
<span class="pc bpc" id="L1375" title="1 of 2 branches missed.">				if (!includeExi) {</span>
<span class="nc" id="L1376">					this.cti--; // roll-back</span>
				} else {
					// roll-back
<span class="fc" id="L1379">					exiSequenceNumbers.put(rsName, exiSeqNum);</span>
				}

				// If the OSCORE profile is used, and this was a first-released
				// Token to this client for RS in question, roll-back the
				// counter used for the 'id' parameter in the OSCORE Security
				// Context and the Id Context value assigned for this Resource
				// Server
<span class="pc bpc" id="L1387" title="2 of 4 branches missed.">				if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="fc" id="L1388">					this.OSCORE_material_counter--;</span>
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">					if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1390">						this.idContextInfoMap.get(audStr).rollback();</span>
					}
				}

<span class="fc" id="L1394">				CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1395">				map.Add(Constants.ERROR, &quot;No common security context found for audience&quot;);</span>
<span class="fc" id="L1396">				LOGGER.log(Level.INFO, &quot;Message processing aborted: No common security context found for audience&quot;);</span>
<span class="fc" id="L1397">				DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Message processing aborted: No common security context found for audience&quot;);
<span class="fc" id="L1399">				return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, map);</span>
			}
<span class="fc" id="L1401">			CWT cwt = (CWT) token;</span>
<span class="fc" id="L1402">			Map&lt;HeaderKeys, CBORObject&gt; uHeaders = null;</span>
<span class="pc bpc" id="L1403" title="1 of 2 branches missed.">			if (this.setAudHeader) {</span>
				// Add the audience as the KID in the header, so it can be
				// referenced by introspection requests.
<span class="nc" id="L1406">				CBORObject requestedAud = CBORObject.NewArray();</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">				for (String a : aud) {</span>
<span class="nc" id="L1408">					requestedAud.Add(a);</span>
<span class="nc" id="L1409">				}</span>
<span class="nc" id="L1410">				uHeaders = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1411">				uHeaders.put(HeaderKeys.KID, requestedAud);</span>
			}
			try {
<span class="fc" id="L1414">				rsInfo.Add(Constants.ACCESS_TOKEN, cwt.encode(ctx, null, uHeaders).EncodeToBytes());</span>
<span class="nc" id="L1415">			} catch (IllegalStateException | InvalidCipherTextException | CoseException | AceException e) {</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">				if (!includeExi) {</span>
<span class="nc" id="L1417">					this.cti--; // roll-back</span>
				} else {
					// roll-back
<span class="nc" id="L1420">					exiSequenceNumbers.put(rsName, exiSeqNum);</span>
				}

				// If the OSCORE profile is used, and this was a first-released
				// Token to this client for RS in question, roll-back the
				// counter used for the 'id' parameter in the OSCORE Security
				// Context and the Id Context value assigned for this Resource
				// Server
<span class="nc bnc" id="L1428" title="All 4 branches missed.">				if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1429">					this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">					if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1431">						this.idContextInfoMap.get(audStr).rollback();</span>
					}
				}

<span class="nc" id="L1435">				LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1436">				DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1437">				return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1438">			}</span>
<span class="fc" id="L1439">		} else {</span>
<span class="fc" id="L1440">			rsInfo.Add(Constants.ACCESS_TOKEN, token.encode().EncodeToBytes());</span>
		}

		try {

			// If the claim set includes EXI but not EXP, then extend the claim
			// set to be stored as follows:
			//
			// 1. Add an EXP claim, computed as current time plus the EXI value.
			// This allows to purge the token if expired, even though it was
			// created without the EXP claim.
			//
			// 2. Add an internal &quot;sentinel claim&quot; to signal the presence of the
			// artificially added EXP claim.
			// In case of introspection, this allows the Authorization Server to
			// return the Access Token like it was originally issued, i.e.,
			// without the EXI claim if this was artificially added.
<span class="pc bpc" id="L1457" title="1 of 4 branches missed.">			if (claims.containsKey(Constants.EXI) &amp;&amp; !claims.containsKey(Constants.EXP)) {</span>

<span class="fc" id="L1459">				Long now = this.time.getCurrentTime();</span>
<span class="fc" id="L1460">				Long exp = now + claims.get(Constants.EXI).AsNumber().ToInt64Checked();</span>

<span class="fc" id="L1462">				claims.put(Constants.EXP, CBORObject.FromObject(exp));</span>

				// Add the &quot;sentinel claim&quot;
<span class="fc" id="L1465">				claims.put(Constants.LATE_ADDED_EXP, CBORObject.True);</span>
			}

<span class="fc" id="L1468">			this.db.addToken(ctiStr, claims);</span>
<span class="fc" id="L1469">			this.db.addCti2Client(ctiStr, id);</span>
<span class="fc bfc" id="L1470" title="All 2 branches covered.">			if (!includeExi) {</span>
<span class="fc" id="L1471">				this.db.saveCtiCounter(this.cti);</span>
			} else {
<span class="fc" id="L1473">				this.db.saveExiSequenceNumber(exiSeqNum + 1, rsName);</span>
			}

			// In case the client has asked to use a PSK, store further
			// associations, to support the issuing of Access Tokens for
			// updating access rights
<span class="fc bfc" id="L1479" title="All 4 branches covered.">			if (keyType != null &amp;&amp; keyType.equals(&quot;PSK&quot;)) {</span>

<span class="fc" id="L1481">				this.cti2aud.put(ctiStr, audStr);</span>

<span class="fc bfc" id="L1483" title="All 2 branches covered.">				if (profile == Constants.COAP_OSCORE) {</span>
					CBORObject oscId;
<span class="pc bpc" id="L1485" title="1 of 2 branches missed.">					if (updateAccessRights == false) {</span>
						// The Token is not updating access rights, hence the
						// identifier of the OSCORE Input Material is the 'id'
						// 'OSCORE_Input_Material' element of the 'cnf' claim
<span class="fc" id="L1489">						oscId = claims.get(Constants.CNF).get(Constants.OSCORE_Input_Material).get(Constants.OS_ID);</span>
					} else {
						// The Token is updating access rights, hence the
						// identifier of the
						// OSCORE Input Material is used as 'kid' in the 'cnf'
						// claim of the Token
<span class="nc" id="L1495">						oscId = claims.get(Constants.CNF).get(Constants.COSE_KID_CBOR);</span>
					}

					// A deep copy is needed
<span class="fc" id="L1499">					byte[] oscIdCopy = Arrays.copyOf(oscId.GetByteString(), oscId.GetByteString().length);</span>
<span class="fc" id="L1500">					this.cti2oscId.put(ctiStr, CBORObject.FromObject(oscIdCopy));</span>

<span class="pc bpc" id="L1502" title="1 of 2 branches missed.">				} else if (profile == Constants.COAP_DTLS) {</span>
					// Regardless if the Token is updating access rights or not,
					// the identifier of the PoP key is the 'kid' parameter
					// inside the 'COSE_Key' parameter of the 'cnf' claim
<span class="fc" id="L1506">					CBORObject kid = claims.get(Constants.CNF).get(Constants.COSE_KEY).get(KeyKeys.KeyId.AsCBOR());</span>

					// A deep copy is needed
<span class="fc" id="L1509">					byte[] kidCopy = Arrays.copyOf(kid.GetByteString(), kid.GetByteString().length);</span>
<span class="fc" id="L1510">					this.cti2kid.put(ctiStr, CBORObject.FromObject(kidCopy));</span>

				}

				// The just issued Token is updating access rights, hence delete
				// the superseded Token
<span class="pc bpc" id="L1516" title="1 of 2 branches missed.">				if (updateAccessRights == true) {</span>
<span class="nc" id="L1517">					removeToken(oldCti);</span>
				}

			}

<span class="fc" id="L1522">		} catch (AceException e) {</span>
<span class="pc bpc" id="L1523" title="1 of 2 branches missed.">			if (!includeExi) {</span>
<span class="nc" id="L1524">				this.cti--; // roll-back</span>
			} else {
				// roll-back
<span class="fc" id="L1527">				exiSequenceNumbers.put(rsName, exiSeqNum);</span>
			}

<span class="fc" id="L1530">			this.cti2aud.remove(ctiStr);</span>

<span class="pc bpc" id="L1532" title="2 of 4 branches missed.">			if (keyType != null &amp;&amp; keyType.equals(&quot;PSK&quot;)) {</span>

<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">				if (profile == Constants.COAP_OSCORE) {</span>
<span class="pc bpc" id="L1535" title="1 of 2 branches missed.">					if (updateAccessRights == false) {</span>
						// Roll-back the counter used for the 'id' parameter in
						// the OSCORE Security Context and the Id Context value
						// assigned for this Resource Server
<span class="fc" id="L1539">						this.OSCORE_material_counter--;</span>
<span class="pc bpc" id="L1540" title="1 of 2 branches missed.">						if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1541">							this.idContextInfoMap.get(audStr).rollback();</span>
						}
					}

<span class="fc" id="L1545">					this.cti2oscId.remove(ctiStr);</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">				} else if (profile == Constants.COAP_DTLS) {</span>
<span class="nc" id="L1547">					this.cti2kid.remove(ctiStr);</span>
				}

			}

<span class="fc" id="L1552">			LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="fc" id="L1553">			DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="fc" id="L1554">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1555">		}</span>
<span class="fc" id="L1556">		LOGGER.log(Level.INFO, &quot;Returning token: &quot; + ctiStr);</span>
<span class="fc" id="L1557">		DhtLogger.sendLog(TYPE_INFO, PRIO_LOW, CAT_STATUS, DEVICE_NAME, &quot;Returning token. &quot; + &quot;[ctiStr: &quot; + ctiStr</span>
				+ &quot;. &quot; + &quot;rsName: &quot; + rsName + &quot;. &quot; + &quot;audStr: &quot; + audStr + &quot;. &quot; + &quot;id: &quot; + id + &quot;]&quot;);

		// ctiStr in base64, rsName, audStr, id
		//
		// If the EXP claim was added after the actual creation of the Access
		// Token, then print all the claims except for EXP and the sentinel
		// claim.
<span class="fc bfc" id="L1565" title="All 2 branches covered.">		if (claims.containsKey(Constants.LATE_ADDED_EXP)) {</span>
<span class="fc" id="L1566">			Map&lt;Short, CBORObject&gt; actualClaims = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1567" title="All 2 branches covered.">			for (Short s : claims.keySet()) {</span>
<span class="fc" id="L1568">				actualClaims.put(s, claims.get(s));</span>
<span class="fc" id="L1569">			}</span>
<span class="fc" id="L1570">			LOGGER.log(Level.FINEST, &quot;Claims: &quot; + actualClaims.toString());</span>
		}
<span class="fc" id="L1572">		return msg.successReply(Message.CREATED, rsInfo);</span>
	}

	/**
	 * Populate RS_CNF
	 * 
	 * @throws AceException
	 */
	private Set&lt;CBORObject&gt; makeRsCnf(Set&lt;String&gt; aud) throws AceException {
<span class="nc" id="L1581">		Set&lt;String&gt; rss = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1582">		Set&lt;CBORObject&gt; rscnfs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">		for (String audE : aud) {</span>
<span class="nc" id="L1584">			rss.addAll(this.db.getRSS(audE));</span>
<span class="nc" id="L1585">		}</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">		for (String rs : rss) {</span>
<span class="nc" id="L1587">			OneKey rsKey = this.db.getRsRPK(rs);</span>
<span class="nc" id="L1588">			CBORObject rscnf = CBORObject.NewMap();</span>
<span class="nc" id="L1589">			rscnf.Add(Constants.COSE_KEY_CBOR, rsKey.AsCBOR());</span>
<span class="nc" id="L1590">			rscnfs.add(rscnf);</span>

<span class="nc" id="L1592">		}</span>
<span class="nc" id="L1593">		return rscnfs;</span>
	}

	/**
	 * Create the value of a 'cnf' claim as an &quot;OSCORE_Input_Material&quot; CBOR
	 * object.
	 * 
	 * @param masterSecret the OSCORE Master Secret
	 * @param rsName the name of the Resource Server
	 * 
	 * @return the value of a 'cnf' claim as an &quot;OSCORE_Input_Material&quot; CBOR
	 *         object
	 */
	synchronized private CBORObject makeOscoreCnf(byte[] masterSecret, String rsName) {
<span class="fc" id="L1607">		CBORObject osccnf = CBORObject.NewMap();</span>
<span class="fc" id="L1608">		CBORObject osc = CBORObject.NewMap();</span>

<span class="fc" id="L1610">		osc.Add(Constants.OS_MS, masterSecret);</span>

<span class="fc" id="L1612">		osc.Add(Constants.OS_ID, Util.intToBytes(OSCORE_material_counter));</span>
<span class="fc" id="L1613">		OSCORE_material_counter++;</span>

<span class="fc bfc" id="L1615" title="All 2 branches covered.">		if (masterSaltSize != 0) {</span>
<span class="fc" id="L1616">			byte[] masterSalt = new byte[masterSaltSize];</span>
<span class="fc" id="L1617">			new SecureRandom().nextBytes(masterSalt);</span>
<span class="fc" id="L1618">			osc.Add(Constants.OS_SALT, masterSalt);</span>
		}

<span class="fc bfc" id="L1621" title="All 2 branches covered.">		if (this.provideIdContext == true) {</span>

			IdContextInfo idContextInfo;
<span class="pc bpc" id="L1624" title="1 of 2 branches missed.">			if (this.idContextInfoMap.containsKey(rsName)) {</span>
<span class="nc" id="L1625">				idContextInfo = this.idContextInfoMap.get(rsName);</span>
			} else {
				// This is the first Access Token for this Resource Server
<span class="fc" id="L1628">				idContextInfo = new IdContextInfo();</span>
<span class="fc" id="L1629">				this.idContextInfoMap.put(rsName, idContextInfo);</span>
			}

<span class="fc" id="L1632">			byte[] idContext = idContextInfo.getIdContext();</span>
<span class="fc" id="L1633">			osc.Add(Constants.OS_CONTEXTID, idContext);</span>

		}

<span class="fc" id="L1637">		osccnf.Add(Constants.OSCORE_Input_Material, osc);</span>
<span class="fc" id="L1638">		return osccnf;</span>
	}

	/**
	 * Create the value of a 'cnf' claim as a &quot;kid&quot; CBOR object.
	 * 
	 * @param oscId the Identifier of the OSCORE Input Material object
	 * 
	 * @return the value of a 'cnf' claim as a &quot;kid&quot; CBOR object
	 */
	private CBORObject makeOscoreCnfUpdateAccessRights(CBORObject oscId) {
<span class="fc" id="L1649">		CBORObject osccnf = CBORObject.NewMap();</span>

<span class="fc" id="L1651">		osccnf.Add(Constants.COSE_KID_CBOR, oscId);</span>
<span class="fc" id="L1652">		return osccnf;</span>
	}

	/**
	 * Process an authorization grant message
	 * 
	 * @param msg the message
	 * 
	 * @return the reply
	 */
	private Message processAC(Message msg) {
		// 3. Check if the request has a grant
<span class="fc" id="L1664">		CBORObject cbor = msg.getParameter(Constants.CODE);</span>
<span class="pc bpc" id="L1665" title="1 of 2 branches missed.">		if (cbor == null) {</span>
<span class="nc" id="L1666">			CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1667">			map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L1668">			map.Add(Constants.ERROR_DESCRIPTION, &quot;No code found for message&quot;);</span>
<span class="nc" id="L1669">			LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No code found for message&quot;);</span>
<span class="nc" id="L1670">			return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
		}
<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">		if (!cbor.getType().equals(CBORType.TextString)) {</span>
<span class="nc" id="L1673">			CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1674">			map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L1675">			map.Add(Constants.ERROR_DESCRIPTION, &quot;Invalid grant format&quot;);</span>
<span class="nc" id="L1676">			LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Invalid grant format&quot;);</span>
<span class="nc" id="L1677">			return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
		}
<span class="fc" id="L1679">		String code = cbor.AsString();</span>

		// 4. Check if grant valid and unused
		try {
<span class="pc bpc" id="L1683" title="1 of 2 branches missed.">			if (!this.db.isGrantValid(code)) {</span>
<span class="nc" id="L1684">				CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1685">				map.Add(Constants.ERROR, Constants.INVALID_GRANT);</span>
<span class="nc" id="L1686">				LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Invalid grant&quot;);</span>
<span class="nc" id="L1687">				return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
			}
<span class="nc" id="L1689">		} catch (AceException e) {</span>
<span class="nc" id="L1690">			LOGGER.log(Level.SEVERE, &quot;Message processing aborted &quot; + &quot;(checking grant): &quot; + e.getMessage());</span>
<span class="nc" id="L1691">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1692">		}</span>

		// 5. Mark grant invalid
		try {
<span class="fc" id="L1696">			this.db.useGrant(code);</span>
<span class="nc" id="L1697">		} catch (AceException e) {</span>
<span class="nc" id="L1698">			LOGGER.log(Level.SEVERE, &quot;Message processing aborted &quot; + &quot;(marking grant invalid): &quot; + e.getMessage());</span>
<span class="nc" id="L1699">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1700">		}</span>

		// 6. Return the RS Information
<span class="fc" id="L1703">		CBORObject rsInfo = CBORObject.NewMap();</span>

		try {
<span class="fc" id="L1706">			Map&lt;Short, CBORObject&gt; rsInfoDB = this.db.getRsInfo(code);</span>
<span class="fc bfc" id="L1707" title="All 2 branches covered.">			for (Map.Entry&lt;Short, CBORObject&gt; e : rsInfoDB.entrySet()) {</span>
<span class="fc" id="L1708">				rsInfo.Add(e.getKey(), e.getValue());</span>
<span class="fc" id="L1709">			}</span>
<span class="nc" id="L1710">		} catch (AceException e) {</span>
<span class="nc" id="L1711">			LOGGER.log(Level.SEVERE, &quot;Message processing aborted &quot; + &quot;(collecting RS Info&quot; + e.getMessage());</span>
<span class="nc" id="L1712">			return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1713">		}</span>

<span class="pc bpc" id="L1715" title="2 of 4 branches missed.">		if (rsInfo == null || !rsInfo.getType().equals(CBORType.Map)) {</span>
<span class="nc" id="L1716">			LOGGER.log(Level.SEVERE, &quot;Message processing aborted: &quot; + &quot;no RS information found for grant: &quot; + code);</span>
<span class="nc" id="L1717">			CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1718">			map.Add(Constants.ERROR, Constants.INVALID_GRANT);</span>
<span class="nc" id="L1719">			map.Add(Constants.ERROR_DESCRIPTION, &quot;No token found for grant&quot;);</span>
<span class="nc" id="L1720">			return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
		}
<span class="fc" id="L1722">		return msg.successReply(Message.CREATED, rsInfo);</span>
	}

	private boolean isSupported(String keyType, Set&lt;String&gt; aud) throws AceException {
<span class="fc" id="L1726">		Set&lt;String&gt; keyTypes = this.db.getSupportedPopKeyTypes(aud);</span>
<span class="fc" id="L1727">		return keyTypes.contains(keyType);</span>
	}

	/**
	 * Retrieves a key from a cnf structure.
	 * 
	 * @param cnf the cnf structure
	 * 
	 * @return the key
	 * 
	 * @throws AceException
	 * @throws CoseException
	 */
	private OneKey getKey(CBORObject cnf, String id) throws AceException, CoseException {
<span class="fc" id="L1741">		CBORObject crpk = null;</span>
<span class="fc bfc" id="L1742" title="All 2 branches covered.">		if (cnf.ContainsKey(Constants.COSE_KEY_CBOR)) {</span>
<span class="fc" id="L1743">			crpk = cnf.get(Constants.COSE_KEY_CBOR);</span>
<span class="pc bpc" id="L1744" title="1 of 2 branches missed.">			if (crpk == null) {</span>
<span class="nc" id="L1745">				return null;</span>
			}
<span class="fc" id="L1747">			return new OneKey(crpk);</span>
<span class="fc bfc" id="L1748" title="All 2 branches covered.">		} else if (cnf.ContainsKey(Constants.COSE_ENCRYPTED_CBOR)) {</span>
<span class="fc" id="L1749">			Encrypt0Message msg = new Encrypt0Message();</span>
<span class="fc" id="L1750">			CBORObject encC = cnf.get(Constants.COSE_ENCRYPTED_CBOR);</span>
			try {
<span class="nc" id="L1752">				msg.DecodeFromCBORObject(encC);</span>
<span class="nc" id="L1753">				OneKey psk = this.db.getCPSK(id);</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">				if (psk == null) {</span>
<span class="nc" id="L1755">					LOGGER.severe(&quot;Couldn't find a key to decrypt cnf parameter&quot;);</span>
<span class="nc" id="L1756">					throw new AceException(&quot;No key found to decrypt cnf parameter&quot;);</span>
				}
<span class="nc" id="L1758">				CBORObject key = psk.get(KeyKeys.Octet_K);</span>
<span class="nc bnc" id="L1759" title="All 4 branches missed.">				if (key == null || !key.getType().equals(CBORType.ByteString)) {</span>
<span class="nc" id="L1760">					LOGGER.severe(&quot;Corrupt key retrieved from database&quot;);</span>
<span class="nc" id="L1761">					throw new AceException(&quot;Key error in the database&quot;);</span>
				}
<span class="nc" id="L1763">				msg.decrypt(key.GetByteString());</span>
<span class="nc" id="L1764">				CBORObject keyData = CBORObject.DecodeFromBytes(msg.GetContent());</span>
<span class="nc" id="L1765">				return new OneKey(keyData);</span>
<span class="fc" id="L1766">			} catch (CoseException e) {</span>
<span class="fc" id="L1767">				LOGGER.severe(&quot;Error while decrypting a cnf claim: &quot; + e.getMessage());</span>
<span class="fc" id="L1768">				throw new AceException(&quot;Error while decrypting a cnf parameter&quot;);</span>
			}
		} // Note: We checked the COSE_KID_CBOR case before
<span class="fc" id="L1771">		throw new AceException(&quot;Malformed cnf structure&quot;);</span>
	}

	/**
	 * Removes a token from the registry
	 * 
	 * @param cti the token identifier Base64 encoded
	 * @throws AceException
	 */
	public void removeToken(String cti) throws AceException {
<span class="nc" id="L1781">		this.db.deleteToken(cti);</span>

<span class="nc" id="L1783">		this.cti2aud.remove(cti);</span>
<span class="nc" id="L1784">		this.cti2oscId.remove(cti);</span>
<span class="nc" id="L1785">		this.cti2kid.remove(cti);</span>

		// FIXME: Add the token to the TRL
<span class="nc" id="L1788">	}</span>

	@Override
	public void close() throws AceException {
<span class="nc" id="L1792">		this.db.saveCtiCounter(this.cti);</span>

<span class="nc bnc" id="L1794" title="All 2 branches missed.">		for (String rs : exiSequenceNumbers.keySet())</span>
<span class="nc" id="L1795">			this.db.saveExiSequenceNumber(exiSequenceNumbers.get(rs).intValue(), rs);</span>

<span class="nc" id="L1797">		this.db.close();</span>
<span class="nc" id="L1798">	}</span>

	/**
	 * Relevant only when the OSCORE profile is used
	 * 
	 * An instance of this class tracks the status of OSCORE Id Contexts
	 * assigned to a Resource Server
	 */
	class IdContextInfo {

		short currentSize;
		int currentValue;

<span class="fc" id="L1811">		public IdContextInfo() {</span>
<span class="fc" id="L1812">			currentSize = 1;</span>
<span class="fc" id="L1813">			currentValue = 0;</span>
<span class="fc" id="L1814">		}</span>

		// Retrieve the next unassigned IdContext for this Resource Server,
		// using the smallest possible size in bytes. That is, first consume all
		// the Id Contexts of 1 byte in size, then all the Id Contexts of 2
		// bytes in size, and so on up to 4 bytes in size.
		synchronized public byte[] getIdContext() {

			// Check if the size has to be changed
<span class="pc bpc" id="L1823" title="2 of 3 branches missed.">			switch (currentSize) {</span>

			case 1: // Max value: 2^8 - 1
			case 2: // Max value: 2^16 - 1
			case 3: // Max value: 2^24 - 1
<span class="pc bpc" id="L1828" title="1 of 2 branches missed.">				if (currentValue == ((1 &lt;&lt; (currentSize * 8)) - 1)) {</span>
<span class="nc" id="L1829">					currentSize++;</span>
<span class="nc" id="L1830">					currentValue = 0;</span>
				}
				break;
			case 4: // Max value: 2^31 - 1 --- The other half is for negative
					// integers
<span class="nc bnc" id="L1835" title="All 2 branches missed.">				if (currentValue == ((1 &lt;&lt; ((currentSize * 8) - 1)) - 1)) {</span>
<span class="nc" id="L1836">					currentSize = 1;</span>
<span class="nc" id="L1837">					currentValue = 0;</span>
				}
				break;
			default:
<span class="nc" id="L1841">				return null;</span>
			}

<span class="fc" id="L1844">			byte[] idContext = null;</span>
<span class="pc bpc" id="L1845" title="4 of 5 branches missed.">			switch (currentSize) {</span>
			case 1:
<span class="fc" id="L1847">				idContext = new byte[] { (byte) (currentValue) };</span>
<span class="fc" id="L1848">				break;</span>
			case 2:
<span class="nc" id="L1850">				idContext = new byte[] { (byte) (currentValue &gt;&gt;&gt; 8), (byte) currentValue };</span>
<span class="nc" id="L1851">				break;</span>
			case 3:
<span class="nc" id="L1853">				idContext = new byte[] { (byte) (currentValue &gt;&gt;&gt; 16), (byte) (currentValue &gt;&gt;&gt; 8),</span>
						(byte) currentValue };
<span class="nc" id="L1855">				break;</span>
			case 4:
<span class="nc" id="L1857">				idContext = new byte[] { (byte) (currentValue &gt;&gt;&gt; 24), (byte) (currentValue &gt;&gt;&gt; 16),</span>
						(byte) (currentValue &gt;&gt;&gt; 8), (byte) currentValue };
				break;
			}

<span class="fc" id="L1862">			currentValue++;</span>
<span class="fc" id="L1863">			return idContext;</span>

		}

		// Free up the Id Context latest assigned for this Resource Server
		synchronized public void rollback() {

<span class="nc bnc" id="L1870" title="All 2 branches missed.">			if (currentValue != 0) {</span>
<span class="nc" id="L1871">				currentValue--;</span>
			} else {
<span class="nc bnc" id="L1873" title="All 3 branches missed.">				switch (currentSize) {</span>
				case 1: // Restore the maximum value: 2^31 - 1 --- The other
						// half is for negative integers
<span class="nc" id="L1876">					currentSize = 4;</span>
<span class="nc" id="L1877">					currentValue = (1 &lt;&lt; ((currentSize * 8) - 1)) - 1;</span>
<span class="nc" id="L1878">					break;</span>
				case 2: // Restore the maximum value: 2^8 - 1
				case 3: // Restore the maximum value: 2^16 - 1
				case 4: // Restore the maximum value: 2^24 - 1
<span class="nc" id="L1882">					currentSize--;</span>
<span class="nc" id="L1883">					currentValue = (1 &lt;&lt; (currentSize * 8)) - 1;</span>
					break;
				}
			}
<span class="nc" id="L1887">		}</span>

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>